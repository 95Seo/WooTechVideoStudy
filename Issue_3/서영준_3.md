# 인덱스란?

인덱스는 데이터를 빠르게 찾을 수 있는 장치로서, **추가적인 쓰기 작업과 저장 공간을 활용**하여 데이터베이스의 테이블의 검색 속도를 향상 시키는 자료구조 입니다.

특정 칼럼에 인덱스를 생성하면 해당 칼럼의 데이터들을 정렬하여 별도의 메모리공간에 데이터의 물리적 주소와 함께 컬럼의 값과 물리적 주소를 (key, value)의 한 쌍으로 저장됩니다.

![index](https://user-images.githubusercontent.com/90227655/200110888-ae278695-117f-4000-9094-f048e7465090.jpg)

이렇게 인덱스를 적용하면 SELECT 이외의 UPDATE나 DELETE등 WHERE 조건을 사용하는 쿼리 수행 시 옵티마이저의 판단하에 인덱스를 이용해 더 빠른 검색 기능을 제공합니다.

> 💡 옵티마이저
> 옵티마이저는 가장 효율적인 방법으로 SQL을 수행할 최적의 처리 경로를 생성해주는 DBMS의 핵심 엔진이다. 컴퓨터의 두뇌가 CPU인 것처럼 DBMS의 두뇌는옵티마이저라고 할 수 있다.

### 왜 효율적일까?

인덱스는 정렬된 자료구조를 가집니다. 이를 통해 데이터 조회 시 많은 이점을 가질 수 있습니다. 또한, 균형잡힌 **B-Tree 기반**으로 구축되어 있어서 탐색에 평균 O(logN) 시간이 걸리며 트리 생성 시의 대수 확장성이란 특징으로 인해 더 빠른 시간 안에 많은 양의 데이터를 빠르게 찾을 수 있습니다.

</br>

# 인덱스를 통해 얻을 수 있는 효과

### 1. 검색 효율 향상

테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드는 내부적으로 순서가 없이 뒤죽박죽으로 저장됩니다. 이때 Where절을 활용해 특정 조건의 칼럼을 찾으려 하면 풀 테이블 스캔 (Full Table Scan)이 작동합니다. 하지만 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건 (Where)에 맞는 데이터들을 빠르게 찾아낼 수 있습니다.

> 💡 풀 테이블 스캔 (Full Table Scan)
> index를 사용하지 않은 컬럼을 조회할 때 테이블 전체를 탐색하며 검색 조건과 맞는지 비교 하는 것을 Full Scan이라 합니다. Full Scan은 전체를 비교하여 탐색하기 때문에 처리 속도가 떨어집니다.

### 2. 정렬 효율성 향상

인덱스를 사용하면 Order by에 의한 부하를 피할수가 있습니다. Order by는 굉장히 부하가 많이 걸리는 작업입니다. 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 디스크 I/O도 추가적으로 발생됩니다. 하지만 인덱스를 사용하면 이미 정렬이 되어 있기 때문에 이러한 자원의 소모를 피할 수 있습니다.

### 3. ****MIN, MAX의 효율적인 처리****

인덱스를 사용하면 정렬된 데이터로 인해 MIN값과 MAX값을 레코드의 시작값과 끝 값 한건씩만 가져오면 되기에 효율적으로 처리할 수 있습니다.

</br>

# 인덱스의 단점

인덱스의 고질적인 문제점은 **데이터의 정렬을 항상 유지해 줘야 한다**는 것 입니다. 그렇기 때문에 데이터가 자주 바뀌는 칼럼이라면 추가적인 부하를 가져올 수 있습니다.

### 1. 인덱스를 관리하기 위한 추가 작업 필요

INSERT, UPDATE, DELETE를 통해 데이터가 추가되거나 값이 바뀐다면 인덱스 테이블 내에 있는 값도 별도의 과정이 추가적으로 발생 합니다.

**INSERT의** 경우 **INDEX에 대한 데이터도 추가**해야 하므로 그만큼 성능에 손실이 일어 납니다.

**DELETE**의 경우 **INDEX의 값을 삭제하면 다시 정렬해야 하기에 그에 따른 부하가 발생하게 됩니다.** INDEX는 이러한 부하를 최소화 하기 위해 **DELETE 시 존재하는 값은 삭제하지 않고 사용 하지 않는다라는 표시로 남게 됩니다.** 즉 **row의 수는 그대로**인 것입니다.

> 이 작업이 반복되면 어떻게 될까요?
실제 데이터는 10만건인데 데이터가 100만건 있는 결과를 낳을 수도 있습니다. 이렇게 되면 인덱스는 더 이상 제 역할을 수행할 수 없게 됩니다.
>

**UPDATE**의 경우 **INSERT와 DELETE에서 일어나는 문제를 동시에 수반**합니다. 이전 데이터도 삭제되지 않고 INSERT로 인한 split 또한 발생하게 됩니다.

그렇기 때문에 **DML이 빈번한 테이블 보다는 검색을 위주로 하는 테이블에 인덱스를 생성**하는 것이 좋습니다.

### 2. 잘못된 사용으로 인한 성능 저하

인덱스를 사용하는 것이 무조건 적으로 좋을까요? 그렇지 않습니다.

인덱스는 인덱스 테이블의 데이터에 접근 후 실제 데이터가 담긴 물리적 주소를 검색해 찾아 갑니다. 이러한 방식으로 인해 **인덱스는 대용량의 데이터를 가진 테이블에서 뛰어난 효율**을 보입니다.

이해를 위해 극단적인 예시를 들어보겠습니다. 1개의 데이터가 있는 테이블과 100만 대의 데이터가 있는 테이블이 있다고 가정해 보겠습니다. 100만 개의 데이터가 들어있는 테이블이라면 풀 스캔보다는 인덱스 스캔의 효율이 더 뛰어 날 것입니다. 하지만 1개의 데이터가 들어있는 테이블이라면 인덱스 스캔 보다는 풀 스캔의 효율이 더 뛰어날 것입니다.

### 3. 인덱스를 많이 만드는 것은 좋지 않다

인덱스를 관리하기 위해서는 **데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요**합니다. 무턱대고 인덱스를 남발하는 것은 좋지 않습니다. 즉, 속도 향상에 비해 단점들의 COST를 비교해서 인덱스를 만들지 말지 정해야 합니다.

**인덱스가 늘어난다는 말은 데이터베이스의 성능에 부하가 쌓이고 있다는 말과 같습니다.** 많은 인덱스는 DML로 인해 인덱스의 크기가 비대해져 오히려 성능이 저하되는 역효과를 가질 수 있습니다.

그렇기에 **인덱스를 생성하는 것보다는 SQL문을 좀 더 효율적으로 짜는 방향으로 성능을 개선**해 나가야 합니다. **인덱스 생성은 마지막 수단**으로 강구해야 합니다.

</br>

# 인덱스 생성 전략

생성된 인덱스를 가장 효율적으로 사용하려면 최대한 중복이 되지 않으며 데이터의 범위가 넓고 조회가 많거나 정렬된 상태가 유용한 컬럼에 사용하는 것이 좋습니다. 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된 인덱스 테이블이 생성됩니다. 가장 최선은 PK로 인덱스를 거는 것이라고 할 수 있습니다.

1. 규모가 작지 않은 테이블
2. 데이터의 범위가 넓은 칼럼
3. INSERT, UPDATE, DELETE가 자주 발생하지 않는 칼럼
4. 중복되는 데이터가 최소한인 칼럼
5. WHERE, ORDER BY, JOIN 절에 자주 사용되는 칼럼

예를 들어 이름, 나이, 성별 세 가지의 필드를 갖고 있는 테이블이 있다고 가정해 봅시다. 이름은 여러 경우의 수가 존재할 것이며, 나이는 INT 타입을 갖고 있을 것이고, 성별은 남, 여 두 가지 경우에 대해서만 데이터가 존재할 것임을 예측할 수 있습니다. 이 경우 어떤 칼럼에 대해서 인덱스를 생성하는 것이 효율적일 까요?

정답은 이름 입니다. 성별이나 나이는 이름에 비해 값의 범위가 작습니다. 그만큼 데이터의 중복이 일어날 확률이 높으며 데이터의 중복이 많을수록 인덱스를 통해 탐색한 데이터의 양이 많아져 추후 추가적인 탐색이 일어날 확률이 높아집니다.

</br>

# 인덱스의 구조

### [해시 테이블(Hash Table)]

해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 **빠른 데이터 검색이 필요할 때 유용합니다**. 해시 테이블은 Key값을 이용해 고유한 index를 생성하여 그 index에 저장된 값을 꺼내오는 구조입니다.

![해시 테이블](https://user-images.githubusercontent.com/90227655/200110900-8f3aa106-b9e8-480c-9f45-ccad5a262704.png)

해시 테이블 기반의 DB 인덱스는 (데이터=컬럼의 값, 데이터의 위치)를 (Key, Value)로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스를 구현합니다. 해시 테이블의 시간복잡도는 O(1)이며 매우 빠른 검색을 지원합니다. 하지만 DB 인덱스에서 해시 테이블이 사용되는 경우는 제한적인데, 그러한 이유는 해시가 등호(=) 연산에만 특화되었기 때문입니다. 해시 함수는 값이 1이라도 달라지면 완전히 다른 해시 값을 생성하는데, 이러한 특성에 의해 **부등호 연산(>, <)이 자주 사용되는 데이터베이스 검색을 위해서는 해시 테이블이 적합하지 않습니다.** 즉, 예를 들면 "나는"으로 시작하는 모든 데이터를 검색하기 위한 쿼리문은 인덱스의 혜택을 전혀 받지 못하게 됩니다. 이러한 이유로 데이터베이스의 인덱스에서는 B+Tree가 일반적으로 사용됩니다.

### **[B-Tree]**

B-Tree는 탐색 성능을 높이기 위해 균형 있게 높이를 유지하는 Balanced Tree의 일종으로, 모든 leaf node가 같은 level로 유지되도록 자동으로 밸런스를 맞춰주는 Tree입니다. 자식 node의 개수가 2개 이상이며, node 내의 key가 1개 이상일 수 있습니다.

node의 자식 수 중 최댓값을 K라고 하면, 해당 B-Tree를K차 B-Tree라고 합니다. B-Tree는 아래와 같은 특성을 가집니다.

- node의 key의 수가 k개라면, 자식 node의 수는 k+1개이다.
- node의 key는 반드시 정렬된 상태여야 한다.
- 자식 node들의 key는 현재 node의 key를 기준으로 크기 순으로 나뉘게 된다.
- root node는 항상 2개 이상의 자식 node를 갖는다.(root node가 leaf node인 경우 제외)
- M차 트리일 때, root node와 leaf node를 제외한 모든 node는 최소 [M/2], 최대 M개의 서브 트리를 갖는다.
- 모든 leaf node 들은 같은 level에 있어야 한다.

![B-Tree](https://user-images.githubusercontent.com/90227655/200110906-ca3584f2-2b6d-498b-85e9-42c17055f69f.png)

위의 트리는 3차 B-Tree의 예시 입니다. node안에서 key들은 항상 정렬된 상태를 유지하며, 이진 탐색 트리처럼 항상 각 key의 왼쪽 자식은 자신보다 작고, 오른쪽 자식은 자신보다 큰 key값을 가집니다.

![편향된 이진 트리 예시](https://user-images.githubusercontent.com/90227655/200111074-8edf731f-2998-4714-b86a-9619d0da2dcd.png)

**왜 B-Tree를 사용하는 가?**

일반적인 이진 트리의 경우 왼쪽처럼 편향된 트리에서 최악의 경우 leaf node까지 탐색하는데 모든 node를 거치기 때문에 O(N)의 시간이 걸리게 됩니다. 이러한 단점을 보완하기 위해 트리가 편향되지 않도록 항상 밸런스를 유지하는 B-Tree를 사용하게 되었습니다. **B-Tree를 사용하면 최악의 경우에도 O(logN)의 시간을 보장합니다.**

### ****[ B+Tree ]****

B+Tree는 DB의 인덱스를 위해 **자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조**입니다. B+Tree는 모든 노드에 데이터(Value)를 저장했던 BTree와 다른 특성을 가지고 있습니다.

- 리프노드(데이터노드)만 인덱스와 함께 데이터(Value)를 가지고 있고, 나머지 노드(인덱스노드)들은 데이터를 위한 인덱스(Key)만을 갖습니다.
- 리프노드들은 LinkedList로 연결되어 있습니다. 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 됩니다.
- 데이터베이스의 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생될 수 있습니다.

![B+Tree](https://user-images.githubusercontent.com/90227655/200110911-1418c58c-a156-4cee-9202-f457379243ae.png)

이러한 구조로 인해 B+Tree는 2가지 장점을 얻을 수 있습니다.

1. leaf node를 제외하고 데이터를 저장하지 않기 때문에 메모리를 더 확보할 수 있습니다. 따라서 하나의 node에 더 많은 포인터를 가질 수 있으며, 트리의 높이는 더 낮아져 검색 속도를 높일 수 있습니다.
2. Full scan을 하는 경우 B+Tree는 leaf node에만 데이터가 저장되어 있고, leaf node끼리 linked list로 연결되어 있기 때문에 선형 시간이 소모됩니다. 반면 B-Tree는 모든 node를 전부 확인해야 합니다.

이러한 이유로 **B+Tree의 leaf node들을 LinkedList로 연결하여 순차검색을 용이하게 하는 등 B+Tree를 인덱스에 맞게 최적화**하였습니다.  (물론 Best Case에 대해 리프노드까지 가지 않아도 탐색할 수 있는 BTree에 비해 무조건 리프노드까지 가야한다는 단점도 있습니다.)

이러한 이유로 비록 B+Tree는 O(log2n) 의 시간복잡도를 갖지만 해시테이블보다 인덱싱에 더욱 적합한 자료구조가 되었습니다.

</br>

# Clustered Index

- 테이블당 1개만 생성됩니다.
- 보통 유일성과 최소성을 만족하는 기본키 중 하나가 클러스터형 인덱스로 설정됩니다.
- **데이터페이지가 정렬**되서 저장되며 인덱스 페이지의 리프노드에 “데이터페이지”가 들어가 있습니다. 즉, 테이블 자체가 인덱스 입니다. (따로 인덱스 페이지를 만들지 않습니다.)
- 데이터가 추가될 때마다 다시 모든 테이블을 정렬해야 하기 때문에 삽입, 삭제, 수정이 느립니다.
- 항상 정렬상태를 유지하기 때문에 논 클러스터형 인덱스보다 검색 속도가 빠릅니다.
- 테이블 레코드와 인덱스의 순서가 같게 조절 됨.
- 30% 이내에서 사용해야 좋은 선택도를 가집니다.

</br>

# non-Clustered Index

- 테이블당 약 240개의 인덱스를 만들 수 있습니다.
- 클러스터형과 달리 인덱스 페이지의 리프노드에 실제 데이터가 있는 것이 아니라 데이터 페이지에 관한 포인터(RID)만 가집니다.
- 데이터페이지는 정렬되지 않고, 인덱스 페이지만 정렬됩니다.
- 보통 복합키를 만든다고 했을 때 (Compount key) 논 클러스터형 인덱스로 만듭니다.
- 인덱스를 생성할 때 데이터 페이지는 그냥 둔 상태에서 별도의 인덱스 페이지를 따로 만들기 때문에 추가적인 용량을 더 차지합니다.
- 정렬되어있지 않아서 탐색은 느리나. 삽입, 삭제, 수정이 빠릅니다.
- 인덱스의 순서와 데이터의 순서가 일치하지 않습니다.
- 3% 이내에서 사용해야 좋은 선택도를 가집니다.

</br>

# **데이터 구조**

### **Clustered Index**

클러스터형 인덱스를 구성하려면 행 데이터를 해당 열로 정렬한 후에 루트 페이지를 만들게 됩니다. 즉 데이터 페이지는 리프 노드와 같은 것을 확인할 수 있습니다.

![클러스터 인덱스](https://user-images.githubusercontent.com/90227655/200110961-723471fb-c876-459c-adda-29716ce4b135.png)

### **non-Clustered Index**

논 클러스터형 인덱스는 데이터 페이지를 건들지 않고, 별도의 장소에 인덱스 페이지를 생성합니다. 우선 인덱스 페이지의 리프 노드에 인덱스로 구성한 열을 정렬하고 데이터 위치 포인터를 생성합니다. 데이터의 위치 포인트는 클러스터형 인덱스와 달리 ‘페이지 번호 + #오프셋’이 기록되어 바로 데이터 위치를 가리킵니다. indexTest2로 예를 들면 102번 페이지의 두 번째(#2)에 데이터가 있다고 기록하게 됩니다. 그러므로 이 데이터 위치 포인터는 데이터가 위치한 고유한 값이 됩니다.

![논 클러스터 인덱스](https://user-images.githubusercontent.com/90227655/200110964-e67fb1bf-aef2-4d4e-bff8-dd07c4303f19.png)


> 💡 RID(Row ID)
> 데이터 위치 포인터를 RID(Row ID)라 부릅니다. 실제로는 해당하는 행의 ‘파일 그룹 번호-데이터 페이지 번호-행의 순번(데이터 페이지 오프셋)’ 으로 구성되는 포인팅 정보입니다.
